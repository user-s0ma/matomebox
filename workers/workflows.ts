import { WorkflowEntrypoint, type WorkflowEvent, type WorkflowStep } from "cloudflare:workers";
import { eq } from "drizzle-orm";
import { researches } from "@/db/schema";
import { getDrizzleClient } from "@/lib/db";
import { model } from "@/lib/gemini";
import { getBrowser, webSearch } from "@/lib/webSearch";
import { DEEP_SEARCH_QUERIES_PROMPT, DEEP_PROCESS_RESULTS_PROMPT, DEEP_FINAL_REPORT_PROMPT } from "@/lib/prompts";
import { ImageProcessor } from "@/lib/imageProcessing";

interface ResearchParams {
  id: string;
  query: string;
  depth: string;
  breadth: string;
  questions: Array<{ question: string; answer: string }>;
}

export class ResearchWorkflow extends WorkflowEntrypoint<Env, ResearchParams> {
  async run(event: WorkflowEvent<ResearchParams>, step: WorkflowStep) {
    console.log("„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÈñãÂßã");
    try {
      const db = getDrizzleClient();
      const browser = await getBrowser();

      const { id } = event.payload;

      let allImages: any[] = [];

      try {
        const { query, depth, breadth } = event.payload;

        await db.update(researches).set({ status: 1 }).where(eq(researches.id, id));

        const serpQueries = await step.do(
          "generate-search-queries",
          {
            retries: {
              limit: 1,
              delay: "10 seconds",
              backoff: "exponential",
            },
            timeout: "10 minutes",
          },
          async () => {
            return await this.generateSerpQueries(query, parseInt(breadth));
          }
        );

        let allLearnings: string[] = [];
        let allUrls: string[] = [];

        for (const serpQuery of serpQueries) {
          try {
            const browserInstance = await browser.getActiveBrowser();

            const result = await step.do(
              `search-${serpQuery.query.substring(0, 20).replace(/\s+/g, "-")}`,
              {
                retries: {
                  limit: 1,
                  delay: "10 seconds",
                  backoff: "exponential",
                },
                timeout: "10 minutes",
              },
              async () => {
                return await webSearch(browserInstance, serpQuery.query, 5);
              }
            );

            const { learnings, followUpQuestions, processedImages } = await step.do(
              `process-results-${serpQuery.query.substring(0, 20).replace(/\s+/g, "-")}`,
              {
                retries: {
                  limit: 1,
                  delay: "10 seconds",
                  backoff: "exponential",
                },
                timeout: "10 minutes",
              },
              async () => {
                return await this.processSerpResult(serpQuery.query, result, Math.ceil(parseInt(breadth) / 2));
              }
            );

            allLearnings = [...allLearnings, ...learnings];
            allUrls = [...allUrls, ...result.map((item) => item.url).filter(Boolean)];

            if (processedImages && processedImages.length > 0) {
              const selectedImages = processedImages.slice(0, 10 - allImages.length);
              allImages = [...allImages, ...selectedImages];
            }

            await db
              .update(researches)
              .set({
                interim_results: JSON.stringify({
                  learnings: allLearnings,
                  urls: allUrls,
                  images: allImages,
                  progress: (allLearnings.length / (parseInt(breadth) * 5)) * 100,
                }),
              })
              .where(eq(researches.id, id));

            if (parseInt(depth) > 1) {
              const nextQueries = await step.do(
                `generate-followup-queries-${serpQuery.query.substring(0, 15).replace(/\s+/g, "-")}`,
                {
                  retries: {
                    limit: 1,
                    delay: "10 seconds",
                    backoff: "exponential",
                  },
                  timeout: "10 minutes",
                },
                async () => {
                  return await this.generateSerpQueries(followUpQuestions.join("\n"), Math.ceil(parseInt(breadth) / 2), allLearnings);
                }
              );

              for (const nextQuery of nextQueries) {
                const nextResult = await step.do(
                  `deep-search-${nextQuery.query.substring(0, 15).replace(/\s+/g, "-")}`,
                  {
                    retries: {
                      limit: 1,
                      delay: "10 seconds",
                      backoff: "exponential",
                    },
                    timeout: "10 minutes",
                  },
                  async () => {
                    return await webSearch(browserInstance, nextQuery.query, 3);
                  }
                );

                const nextProcessResult = await step.do(
                  `deep-process-${nextQuery.query.substring(0, 15).replace(/\s+/g, "-")}`,
                  {
                    retries: {
                      limit: 1,
                      delay: "10 seconds",
                      backoff: "exponential",
                    },
                    timeout: "10 minutes",
                  },
                  async () => {
                    return await this.processSerpResult(nextQuery.query, nextResult);
                  }
                );

                allLearnings = [...allLearnings, ...nextProcessResult.learnings];
                allUrls = [...allUrls, ...nextResult.map((item) => item.url).filter(Boolean)];

                if (nextProcessResult.processedImages && nextProcessResult.processedImages.length > 0) {
                  const remainingSlots = 10 - allImages.length;
                  if (remainingSlots > 0) {
                    const selectedDeepImages = nextProcessResult.processedImages.slice(0, remainingSlots);
                    allImages = [...allImages, ...selectedDeepImages];
                  }
                }
              }
            }
          } catch (error) {
            console.error(`„ÇØ„Ç®„É™Âá¶ÁêÜ„Ç®„É©„Éº: ${serpQuery.query}`, error);
          }
        }

        const report = await step.do(
          "write-final-report",
          {
            retries: {
              limit: 1,
              delay: "10 seconds",
              backoff: "exponential",
            },
            timeout: "10 minutes",
          },
          async () => {
            return await this.writeFinalReport(query, allLearnings, allUrls, allImages);
          }
        );

        await db
          .update(researches)
          .set({
            result: report,
            status: 2,
            images: JSON.stringify(allImages),
          })
          .where(eq(researches.id, id));

        return { success: true, learningsCount: allLearnings.length, imagesCount: allImages.length };
      } catch (error) {
        console.error("„É™„Çµ„Éº„ÉÅ„Éó„É≠„Çª„ÇπÂ§±Êïó:", error);

        await db
          .update(researches)
          .set({
            status: 3,
            result: `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error instanceof Error ? error.message : String(error)}`,
          })
          .where(eq(researches.id, id));

        return { success: false, error: String(error) };
      } finally {
        await browser.close();
      }
    } catch (error) {
      console.error("„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÂ§±Êïó", error);
      return { success: false, error: String(error) };
    }
  }

  async integrateImageAnalysis(markdown: string, images: any[]): Promise<{ enhancedMarkdown: string; analyzedImages: any[] }> {
    const analyzedImages = [...images];
    let enhancedMarkdown = markdown;

    const sortedImages = [...analyzedImages].sort((a, b) => (a.position || 0) - (b.position || 0));

    for (const img of sortedImages) {
      try {
        console.log(`üñºÔ∏è ÁîªÂÉèÂàÜÊûêÈñãÂßã: ${img.url}`);
        const analysis = await this.analyzeImage(img.url);
        img.analysis = analysis;

        let contextAnalysis = analysis;
        if (img.context) {
          contextAnalysis += `\nÁîªÂÉè„ÅÆÂë®Ëæ∫„ÉÜ„Ç≠„Çπ„Éà: ${img.context}`;
        }

        const placeholder = `[IMAGE_PLACEHOLDER_${img.id}]`;
        const replacement = `\n\n[IMAGE_CONTEXT: ${contextAnalysis}]\n\n[IMAGE_TAG_${img.id}]\n\n`;

        enhancedMarkdown = enhancedMarkdown.replace(placeholder, replacement);
      } catch (error) {
        console.error(`ÁîªÂÉèÂàÜÊûê„Ç®„É©„Éº: ${img.url}`, error);
        enhancedMarkdown = enhancedMarkdown.replace(`[IMAGE_PLACEHOLDER_${img.id}]`, "");
      }
    }

    return { enhancedMarkdown, analyzedImages };
  }

  async generateSerpQueries(query: string, numQueries: number = 5, learnings?: string[]) {
    console.log(`üìÑ Ê§úÁ¥¢„ÇØ„Ç®„É™ÁîüÊàêÈñãÂßã`);

    const { response } = await model.generateContent([
      DEEP_SEARCH_QUERIES_PROMPT() +
        `\n\n‰ª•‰∏ã„ÅÆ„ÉÜ„Éº„Éû„Å´Èñ¢„Åô„ÇãÊ§úÁ¥¢„ÇØ„Ç®„É™„Çí${numQueries}ÂÄãÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n${query}${learnings ? `\n\nÂèÇËÄÉÊÉÖÂ†±Ôºö\n${learnings.join("\n")}` : ""}`,
    ]);
    const content = response.text();

    console.log(`üìÑ Ê§úÁ¥¢„ÇØ„Ç®„É™ÁîüÊàêÂÆå‰∫Ü: ${content.substring(0, 100)}${content.length > 100 ? "..." : ""}`);
    const lines = content.split("\n").filter((line) => line.trim() !== "");
    const queries = lines
      .map((line) => {
        const query = line.replace(/^\d+\.\s*/, "").trim();
        return {
          query: query,
          researchGoal: "Gather information related to the main query",
        };
      })
      .slice(0, numQueries);
    return queries;
  }

  async processSerpResult(query: string, result: any[], numFollowUpQuestions: number = 5, numLearnings: number = 5) {
    console.log(`Ê§úÁ¥¢ÁµêÊûúÂá¶ÁêÜ: ${query}`);

    const processedResults = await Promise.all(
      result.map(async (item) => {
        if (!item.markdown || !item.images || item.images.length === 0) {
          return { enhancedMarkdown: item.markdown || "", analyzedImages: [] };
        }

        return await this.integrateImageAnalysis(item.markdown, item.images);
      })
    );

    const processedImages = processedResults.flatMap((result) => result.analyzedImages).filter((img) => img.analysis);

    const contentsWithImages = processedResults.map((result) => result.enhancedMarkdown);

    if (contentsWithImages.length === 0) {
      console.warn(`Ê§úÁ¥¢„ÇØ„Ç®„É™„Äå${query}„Äç„ÅÆÁµêÊûú„ÅåÁ©∫„Åß„Åô`);
      return {
        learnings: ["Ê§úÁ¥¢ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"],
        followUpQuestions: ["‰ªñ„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅßÊ§úÁ¥¢„Åô„Åπ„Åç„Åß„Åô„ÅãÔºü"],
        processedImages: [],
      };
    }

    console.log(`üìÑ Ê§úÁ¥¢ÁµêÊûúÂá¶ÁêÜÈñãÂßã`);

    const { response } = await model.generateContent([
      DEEP_PROCESS_RESULTS_PROMPT() + `‰ª•‰∏ã„ÅÆÊ§úÁ¥¢ÁµêÊûú„ÇíÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n\nÊ§úÁ¥¢„ÇØ„Ç®„É™: ${query}\n\nÊ§úÁ¥¢ÁµêÊûú:${contentsWithImages.join("\n\n---\n\n")}`,
    ]);
    const content = response.text();

    console.log(`üìÑ Ê§úÁ¥¢ÁµêÊûúÂá¶ÁêÜÂÆå‰∫Ü: ${content.substring(0, 100)}${content.length > 100 ? "..." : ""}`);

    const sections = content.split(/#+\s*Follow-up Questions/i);

    let learnings: string[] = [];
    if (sections.length > 0) {
      learnings = sections[0]
        .split(/\d+\.\s+/)
        .slice(1)
        .map((item) => item.trim())
        .filter(Boolean)
        .slice(0, numLearnings);
    }

    let followUpQuestions: string[] = [];
    if (sections.length > 1) {
      followUpQuestions = sections[1]
        .split(/\d+\.\s+/)
        .slice(1)
        .map((item) => item.trim())
        .filter(Boolean)
        .slice(0, numFollowUpQuestions);
    }

    return { learnings, followUpQuestions, processedImages };
  }

  async analyzeImage(imageUrl: string) {
    try {
      console.log(`üñºÔ∏è ÁîªÂÉèÂàÜÊûêÈñãÂßã: ${imageUrl}`);

      const res = await fetch(imageUrl);
      const blob = await res.arrayBuffer();

      const { response } = await model.generateContent([
        "„Åì„ÅÆÁîªÂÉè„Å´„ÅØ‰Ωï„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÅãÔºüË©≥„Åó„ÅèË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        {
          inlineData: {
            data: Buffer.from(blob).toString("base64"),
            mimeType: res.headers.get("content-type") || "application/octet-stream",
          },
        },
      ]);
      return response.text();
    } catch (error) {
      console.error(`ÁîªÂÉèÂàÜÊûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`);
      return "ÁîªÂÉè„ÅÆÂàÜÊûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü";
    }
  }

  async generateArticleDraft(prompt: string, learnings: string[]): Promise<string> {
    console.log(`üìù Ë®ò‰∫ã„Éâ„É©„Éï„ÉàÁîüÊàêÈñãÂßã: ${prompt}`);

    const { response } = await model.generateContent([
      `„ÅÇ„Å™„Åü„ÅØ„Éó„É≠„ÅÆ„Éã„É•„Éº„ÇπË®òËÄÖ„Åß„Åô„ÄÇÂèéÈõÜ„Åï„Çå„ÅüÊÉÖÂ†±„ÇíÁµ±Âêà„Åó„ÄÅ„Éã„É•„Éº„ÇπË®ò‰∫ã„ÅÆ‰∏ãÊõ∏„Åç„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
  ÁîªÂÉè„ÅØÂê´„ÇÅ„Åö„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Åø„ÅÆ„Éâ„É©„Éï„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ` +
        `‰ª•‰∏ã„ÅÆÊÉÖÂ†±„ÇíÂÖÉ„Å´„ÄÅ„Äå${prompt}„Äç„Å´Èñ¢„Åô„Çã„Éã„É•„Éº„ÇπË®ò‰∫ã„ÅÆ‰∏ãÊõ∏„Åç„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
  ${learnings.map((learning, index) => `${index + 1}. ${learning}`).join("\n")}`,
    ]);
    const draft = response.text();

    console.log(`üìù Ë®ò‰∫ã„Éâ„É©„Éï„ÉàÁîüÊàêÂÆå‰∫Ü: ${draft.substring(0, 100)}${draft.length > 100 ? "..." : ""}`);

    return draft;
  }

  async writeFinalReport(prompt: string, learnings: string[], visitedUrls: string[], images: any[] = []) {
    const articleDraft = await this.generateArticleDraft(prompt, learnings);

    const imageProcessor = new ImageProcessor();

    const articleWithImages = await imageProcessor.processImagesForArticle(articleDraft, images);

    const { response } = await model.generateContent([
      DEEP_FINAL_REPORT_PROMPT() +
        `„Éó„É≠„É≥„Éó„Éà„Äå${prompt}„Äç„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ‰ª•‰∏ã„ÅÆË®ò‰∫ãÂéüÁ®ø„Çí„ÇÇ„Å®„Å´ÊúÄÁµÇÁöÑ„Å™„Éã„É•„Éº„ÇπË®ò‰∫ã„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
  Ë®ò‰∫ã„Å´„ÅØÊó¢„Å´ÁîªÂÉèÈÖçÁΩÆ„Éû„Éº„Ç´„Éº[IMAGE_TAG_...]„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆ„Éû„Éº„Ç´„Éº„ÅÆ‰ΩçÁΩÆ„ÇíÂ∞äÈáç„Åó„Å¶Ë®ò‰∫ã„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
  
  ${articleWithImages}
  
  Âà©Áî®ÂèØËÉΩ„Å™ÁîªÂÉè„ÅÆÊÉÖÂ†±Ôºö
  ${images.map((img) => `[IMAGE_TAG_${img.id}]: ${img.analysis || "Èñ¢ÈÄ£ÁîªÂÉè"}`).join("\n\n")}`,
    ]);
    let report = response.text();

    images.forEach((img) => {
      const imgTag = `\n\n![${img.alt || "Èñ¢ÈÄ£ÁîªÂÉè"}](${img.url})\n*${img.analysis || "Èñ¢ÈÄ£ÁîªÂÉè"}*\n\n`;
      report = report.replace(`[IMAGE_TAG_${img.id}]`, imgTag);
    });

    const urlsSection = `\n\n## ÂèÇËÄÉ„Çµ„Ç§„Éà\n\n${visitedUrls.map((url) => `- ${url}`).join("\n")}`;
    return report + urlsSection;
  }
}
